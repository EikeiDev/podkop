// This file is autogenerated, please don't change manually 
"use strict";
"require baseclass";

// src/validators/validateIp.ts
function validateIPV4(ip) {
  const ipRegex = /^(?:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$/;
  if (ipRegex.test(ip)) {
    return { valid: true, message: "Valid" };
  }
  return { valid: false, message: "Invalid IP address" };
}

// src/validators/validateDomain.ts
function validateDomain(domain) {
  const domainRegex = /^(?=.{1,253}(?:\/|$))(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9-]{1,59}[a-zA-Z0-9])(?:\/[^\s]*)?$/;
  if (!domainRegex.test(domain)) {
    return { valid: false, message: "Invalid domain address" };
  }
  const hostname = domain.split("/")[0];
  const parts = hostname.split(".");
  const atLeastOneInvalidPart = parts.some((part) => part.length > 63);
  if (atLeastOneInvalidPart) {
    return { valid: false, message: "Invalid domain address" };
  }
  return { valid: true, message: "Valid" };
}

// src/validators/validateDns.ts
function validateDNS(value) {
  if (!value) {
    return { valid: false, message: "DNS server address cannot be empty" };
  }
  if (validateIPV4(value).valid) {
    return { valid: true, message: "Valid" };
  }
  if (validateDomain(value).valid) {
    return { valid: true, message: "Valid" };
  }
  return {
    valid: false,
    message: "Invalid DNS server format. Examples: 8.8.8.8 or dns.example.com or dns.example.com/nicedns for DoH"
  };
}

// src/validators/validateUrl.ts
function validateUrl(url, protocols = ["http:", "https:"]) {
  try {
    const parsedUrl = new URL(url);
    if (!protocols.includes(parsedUrl.protocol)) {
      return {
        valid: false,
        message: `URL must use one of the following protocols: ${protocols.join(", ")}`
      };
    }
    return { valid: true, message: "Valid" };
  } catch (e) {
    return { valid: false, message: "Invalid URL format" };
  }
}

// src/validators/validatePath.ts
function validatePath(value) {
  if (!value) {
    return {
      valid: false,
      message: "Path cannot be empty"
    };
  }
  const pathRegex = /^\/[a-zA-Z0-9_\-/.]+$/;
  if (pathRegex.test(value)) {
    return {
      valid: true,
      message: "Valid"
    };
  }
  return {
    valid: false,
    message: 'Invalid path format. Path must start with "/" and contain valid characters'
  };
}

// src/validators/validateSubnet.ts
function validateSubnet(value) {
  const subnetRegex = /^(\d{1,3}\.){3}\d{1,3}(?:\/\d{1,2})?$/;
  if (!subnetRegex.test(value)) {
    return {
      valid: false,
      message: "Invalid format. Use X.X.X.X or X.X.X.X/Y"
    };
  }
  const [ip, cidr] = value.split("/");
  if (ip === "0.0.0.0") {
    return { valid: false, message: "IP address 0.0.0.0 is not allowed" };
  }
  const ipCheck = validateIPV4(ip);
  if (!ipCheck.valid) {
    return ipCheck;
  }
  if (cidr) {
    const cidrNum = parseInt(cidr, 10);
    if (cidrNum < 0 || cidrNum > 32) {
      return {
        valid: false,
        message: "CIDR must be between 0 and 32"
      };
    }
  }
  return { valid: true, message: "Valid" };
}

// src/validators/bulkValidate.ts
function bulkValidate(values, validate) {
  const results = values.map((value) => ({ ...validate(value), value }));
  return {
    valid: results.every((r) => r.valid),
    results
  };
}

// src/validators/validateShadowsocksUrl.ts
function validateShadowsocksUrl(url) {
  if (!url.startsWith("ss://")) {
    return {
      valid: false,
      message: "Invalid Shadowsocks URL: must start with ss://"
    };
  }
  try {
    const mainPart = url.includes("?") ? url.split("?")[0] : url.split("#")[0];
    const encryptedPart = mainPart.split("/")[2]?.split("@")[0];
    if (!encryptedPart) {
      return {
        valid: false,
        message: "Invalid Shadowsocks URL: missing credentials"
      };
    }
    try {
      const decoded = atob(encryptedPart);
      if (!decoded.includes(":")) {
        return {
          valid: false,
          message: "Invalid Shadowsocks URL: decoded credentials must contain method:password"
        };
      }
    } catch (e) {
      if (!encryptedPart.includes(":") && !encryptedPart.includes("-")) {
        return {
          valid: false,
          message: 'Invalid Shadowsocks URL: missing method and password separator ":"'
        };
      }
    }
    const serverPart = url.split("@")[1];
    if (!serverPart) {
      return {
        valid: false,
        message: "Invalid Shadowsocks URL: missing server address"
      };
    }
    const [server, portAndRest] = serverPart.split(":");
    if (!server) {
      return {
        valid: false,
        message: "Invalid Shadowsocks URL: missing server"
      };
    }
    const port = portAndRest ? portAndRest.split(/[?#]/)[0] : null;
    if (!port) {
      return { valid: false, message: "Invalid Shadowsocks URL: missing port" };
    }
    const portNum = parseInt(port, 10);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      return {
        valid: false,
        message: "Invalid port number. Must be between 1 and 65535"
      };
    }
  } catch (e) {
    return { valid: false, message: "Invalid Shadowsocks URL: parsing failed" };
  }
  return { valid: true, message: "Valid" };
}

// src/validators/validateVlessUrl.ts
function validateVlessUrl(url) {
  if (!url.startsWith("vless://")) {
    return {
      valid: false,
      message: "Invalid VLESS URL: must start with vless://"
    };
  }
  try {
    const uuid = url.split("/")[2]?.split("@")[0];
    if (!uuid) {
      return { valid: false, message: "Invalid VLESS URL: missing UUID" };
    }
    const serverPart = url.split("@")[1];
    if (!serverPart) {
      return {
        valid: false,
        message: "Invalid VLESS URL: missing server address"
      };
    }
    const [server, portAndRest] = serverPart.split(":");
    if (!server) {
      return { valid: false, message: "Invalid VLESS URL: missing server" };
    }
    const port = portAndRest ? portAndRest.split(/[/?#]/)[0] : null;
    if (!port) {
      return { valid: false, message: "Invalid VLESS URL: missing port" };
    }
    const portNum = parseInt(port, 10);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      return {
        valid: false,
        message: "Invalid port number. Must be between 1 and 65535"
      };
    }
    const queryString = url.split("?")[1];
    if (!queryString) {
      return {
        valid: false,
        message: "Invalid VLESS URL: missing query parameters"
      };
    }
    const params = new URLSearchParams(queryString.split("#")[0]);
    const type = params.get("type");
    const validTypes = ["tcp", "raw", "udp", "grpc", "http", "ws"];
    if (!type || !validTypes.includes(type)) {
      return {
        valid: false,
        message: "Invalid VLESS URL: type must be one of tcp, raw, udp, grpc, http, ws"
      };
    }
    const security = params.get("security");
    const validSecurities = ["tls", "reality", "none"];
    if (!security || !validSecurities.includes(security)) {
      return {
        valid: false,
        message: "Invalid VLESS URL: security must be one of tls, reality, none"
      };
    }
    if (security === "reality") {
      if (!params.get("pbk")) {
        return {
          valid: false,
          message: "Invalid VLESS URL: missing pbk parameter for reality security"
        };
      }
      if (!params.get("fp")) {
        return {
          valid: false,
          message: "Invalid VLESS URL: missing fp parameter for reality security"
        };
      }
    }
  } catch (e) {
    return { valid: false, message: "Invalid VLESS URL: parsing failed" };
  }
  return { valid: true, message: "Valid" };
}

// src/validators/validateOutboundJson.ts
function validateOutboundJson(value) {
  try {
    const parsed = JSON.parse(value);
    if (!parsed.type || !parsed.server || !parsed.server_port) {
      return {
        valid: false,
        message: 'Outbound JSON must contain at least "type", "server" and "server_port" fields'
      };
    }
    return { valid: true, message: "Valid" };
  } catch {
    return { valid: false, message: "Invalid JSON format" };
  }
}

// src/validators/validateTrojanUrl.ts
function validateTrojanUrl(url) {
  if (!url.startsWith("trojan://")) {
    return {
      valid: false,
      message: "Invalid Trojan URL: must start with trojan://"
    };
  }
  try {
    const parsedUrl = new URL(url);
    if (!parsedUrl.username || !parsedUrl.hostname || !parsedUrl.port) {
      return {
        valid: false,
        message: "Invalid Trojan URL: must contain username, hostname and port"
      };
    }
  } catch (e) {
    return { valid: false, message: "Invalid Trojan URL: parsing failed" };
  }
  return { valid: true, message: "Valid" };
}

// src/helpers/getBaseUrl.ts
function getBaseUrl() {
  const { protocol, hostname } = window.location;
  return `${protocol}//${hostname}`;
}

// src/helpers/parseValueList.ts
function parseValueList(value) {
  return value.split(/\n/).map((line) => line.split("//")[0]).join(" ").split(/[,\s]+/).map((s) => s.trim()).filter(Boolean);
}

// src/styles.ts
var GlobalStyles = `
.cbi-value {
    margin-bottom: 10px !important;
}

#diagnostics-status .table > div {
    background: var(--background-color-primary);
    border: 1px solid var(--border-color-medium);
    border-radius: var(--border-radius);
}

#diagnostics-status .table > div pre,
#diagnostics-status .table > div div[style*="monospace"] {
    color: var(--color-text-primary);
}

#diagnostics-status .alert-message {
    background: var(--background-color-primary);
    border-color: var(--border-color-medium);
}

#cbi-podkop:has(.cbi-tab-disabled[data-tab="basic"]) #cbi-podkop-extra {
    display: none;
}
`;

// src/helpers/injectGlobalStyles.ts
function injectGlobalStyles() {
  document.head.insertAdjacentHTML(
    "beforeend",
    `
        <style>
          ${GlobalStyles}
        </style>
    `
  );
}

// src/constants.ts
var STATUS_COLORS = {
  SUCCESS: "#4caf50",
  ERROR: "#f44336",
  WARNING: "#ff9800"
};
var FAKEIP_CHECK_DOMAIN = "fakeip.podkop.fyi";
var IP_CHECK_DOMAIN = "ip.podkop.fyi";
var REGIONAL_OPTIONS = [
  "russia_inside",
  "russia_outside",
  "ukraine_inside"
];
var ALLOWED_WITH_RUSSIA_INSIDE = [
  "russia_inside",
  "meta",
  "twitter",
  "discord",
  "telegram",
  "cloudflare",
  "google_ai",
  "google_play",
  "hetzner",
  "ovh",
  "hodca",
  "digitalocean",
  "cloudfront"
];
var DOMAIN_LIST_OPTIONS = {
  russia_inside: "Russia inside",
  russia_outside: "Russia outside",
  ukraine_inside: "Ukraine",
  geoblock: "Geo Block",
  block: "Block",
  porn: "Porn",
  news: "News",
  anime: "Anime",
  youtube: "Youtube",
  discord: "Discord",
  meta: "Meta",
  twitter: "Twitter (X)",
  hdrezka: "HDRezka",
  tiktok: "Tik-Tok",
  telegram: "Telegram",
  cloudflare: "Cloudflare",
  google_ai: "Google AI",
  google_play: "Google Play",
  hodca: "H.O.D.C.A",
  hetzner: "Hetzner ASN",
  ovh: "OVH ASN",
  digitalocean: "Digital Ocean ASN",
  cloudfront: "CloudFront ASN"
};
var UPDATE_INTERVAL_OPTIONS = {
  "1h": "Every hour",
  "3h": "Every 3 hours",
  "12h": "Every 12 hours",
  "1d": "Every day",
  "3d": "Every 3 days"
};
var DNS_SERVER_OPTIONS = {
  "1.1.1.1": "1.1.1.1 (Cloudflare)",
  "8.8.8.8": "8.8.8.8 (Google)",
  "9.9.9.9": "9.9.9.9 (Quad9)",
  "dns.adguard-dns.com": "dns.adguard-dns.com (AdGuard Default)",
  "unfiltered.adguard-dns.com": "unfiltered.adguard-dns.com (AdGuard Unfiltered)",
  "family.adguard-dns.com": "family.adguard-dns.com (AdGuard Family)"
};
var BOOTSTRAP_DNS_SERVER_OPTIONS = {
  "77.88.8.8": "77.88.8.8 (Yandex DNS)",
  "77.88.8.1": "77.88.8.1 (Yandex DNS)",
  "1.1.1.1": "1.1.1.1 (Cloudflare DNS)",
  "1.0.0.1": "1.0.0.1 (Cloudflare DNS)",
  "8.8.8.8": "8.8.8.8 (Google DNS)",
  "8.8.4.4": "8.8.4.4 (Google DNS)",
  "9.9.9.9": "9.9.9.9 (Quad9 DNS)",
  "9.9.9.11": "9.9.9.11 (Quad9 DNS)"
};
var DIAGNOSTICS_UPDATE_INTERVAL = 1e4;
var CACHE_TIMEOUT = DIAGNOSTICS_UPDATE_INTERVAL - 1e3;
var ERROR_POLL_INTERVAL = 1e4;
var COMMAND_TIMEOUT = 1e4;
var FETCH_TIMEOUT = 1e4;
var BUTTON_FEEDBACK_TIMEOUT = 1e3;
var DIAGNOSTICS_INITIAL_DELAY = 100;
var COMMAND_SCHEDULING = {
  P0_PRIORITY: 0,
  // Highest priority (no delay)
  P1_PRIORITY: 100,
  // Very high priority
  P2_PRIORITY: 300,
  // High priority
  P3_PRIORITY: 500,
  // Above average
  P4_PRIORITY: 700,
  // Standard priority
  P5_PRIORITY: 900,
  // Below average
  P6_PRIORITY: 1100,
  // Low priority
  P7_PRIORITY: 1300,
  // Very low priority
  P8_PRIORITY: 1500,
  // Background execution
  P9_PRIORITY: 1700,
  // Idle mode execution
  P10_PRIORITY: 1900
  // Lowest priority
};
return baseclass.extend({
  ALLOWED_WITH_RUSSIA_INSIDE,
  BOOTSTRAP_DNS_SERVER_OPTIONS,
  BUTTON_FEEDBACK_TIMEOUT,
  CACHE_TIMEOUT,
  COMMAND_SCHEDULING,
  COMMAND_TIMEOUT,
  DIAGNOSTICS_INITIAL_DELAY,
  DIAGNOSTICS_UPDATE_INTERVAL,
  DNS_SERVER_OPTIONS,
  DOMAIN_LIST_OPTIONS,
  ERROR_POLL_INTERVAL,
  FAKEIP_CHECK_DOMAIN,
  FETCH_TIMEOUT,
  IP_CHECK_DOMAIN,
  REGIONAL_OPTIONS,
  STATUS_COLORS,
  UPDATE_INTERVAL_OPTIONS,
  bulkValidate,
  getBaseUrl,
  injectGlobalStyles,
  parseValueList,
  validateDNS,
  validateDomain,
  validateIPV4,
  validateOutboundJson,
  validatePath,
  validateShadowsocksUrl,
  validateSubnet,
  validateTrojanUrl,
  validateUrl,
  validateVlessUrl
});
